/// @generated by the sqlc-gen-rust on sqlc-generate using sqlc.yaml
/// DO NOT EDIT.
pub(crate) const ALL_BOOKS: &str = r#"
select book_id, author_id, isbn, book_type, title, year, available, tags
from books
"#;
pub(crate) const BOOKS_BY_YEAR: &str = r#"
select book_id, author_id, isbn, book_type, title, year, available, tags
from books
where year = $1
"#;
pub(crate) const CREATE_AUTHOR: &str = r#"
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name, biography
"#;
pub(crate) const CREATE_BOOK: &str = r#"
INSERT INTO books (
  author_id,
  isbn,
  book_type,
  title,
  year,
  available,
  tags
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags
"#;
pub(crate) const DELETE_BOOK: &str = r#"
delete from books
where book_id = $1
"#;
pub(crate) const DELETE_BOOK_EXEC_RESULT: &str = r#"
delete from books
where book_id = $1
"#;
pub(crate) const DELETE_BOOK_NAMED_FUNC: &str = r#"
delete from books
where book_id = $1
"#;
pub(crate) const DELETE_BOOK_NAMED_SIGN: &str = r#"
delete from books
where book_id = $1
"#;
pub(crate) const GET_AUTHOR: &str = r#"
select author_id, name, biography
from authors
where author_id = $1
"#;
pub(crate) const GET_BIOGRAPHY: &str = r#"
select biography
from authors
where author_id = $1
"#;
pub(crate) const UPDATE_BOOK: &str = r#"
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3
"#;
#[derive(postgres_derive::ToSql, postgres_derive::FromSql)]
#[derive(Debug, PartialEq, Clone)]
#[postgres(name = "book_type")]
pub enum BookType {
    #[postgres(name = "FICTION")]
    Fiction,
    #[postgres(name = "NONFICTION")]
    Nonfiction,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive(Debug, PartialEq, Clone)]
pub(crate) struct Author {
    pub author_id: i32,
    pub name: String,
    pub biography: Option<serde_json::Value>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive(Debug, PartialEq, Clone)]
pub(crate) struct Book {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: time::OffsetDateTime,
    pub tags: Vec<String>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive(Debug, PartialEq, Clone)]
pub(crate) struct CreateBookParams {
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: time::OffsetDateTime,
    pub tags: Vec<String>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive(Debug, PartialEq, Clone)]
pub(crate) struct UpdateBookParams {
    pub title: String,
    pub tags: Vec<String>,
    pub book_id: i32,
}
pub(crate) async fn all_books(
    client: &impl sqlc_core::DBTX,
) -> sqlc_core::Result<impl std::iter::Iterator<Item = sqlc_core::Result<Book>>> {
    let rows = client.query(ALL_BOOKS, &[]).await?;
    let iter = rows
        .into_iter()
        .map(|row| Ok(sqlc_core::FromPostgresRow::from_row(&row)?));
    Ok(iter)
}
pub(crate) async fn books_by_year<'a, C, I>(
    client: &'a C,
    year_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<
            Output = sqlc_core::Result<
                impl futures::Stream<Item = sqlc_core::Result<sqlc_core::Result<Book>>>,
            >,
        > + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<i32> + 'a,
{
    let stmt = client.prepare(BOOKS_BY_YEAR).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let year = item.borrow();
            let rows = client.query(&stmt, &[&year]).await?;
            let result = rows
                .into_iter()
                .map(|row| Ok(sqlc_core::FromPostgresRow::from_row(&row)));
            Ok(Box::pin(futures::stream::iter(result)))
        })
    };
    Ok(futures::stream::iter(year_list.into_iter().map(fut)))
}
pub(crate) async fn create_author(
    client: &impl sqlc_core::DBTX,
    name: String,
) -> sqlc_core::Result<Author> {
    let row = client.query_one(CREATE_AUTHOR, &[&name]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn create_book<'a, C, I>(
    client: &'a C,
    arg_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<Book>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<CreateBookParams> + 'a,
{
    let stmt = client.prepare(CREATE_BOOK).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let arg = item.borrow();
            let row = client
                .query_one(
                    &stmt,
                    &[
                        &arg.author_id,
                        &arg.isbn,
                        &arg.book_type,
                        &arg.title,
                        &arg.year,
                        &arg.available,
                        &arg.tags,
                    ],
                )
                .await?;
            Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
        })
    };
    Ok(futures::stream::iter(arg_list.into_iter().map(fut)))
}
pub(crate) async fn delete_book<'a, C, I>(
    client: &'a C,
    book_id_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<()>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<i32> + 'a,
{
    let stmt = client.prepare(DELETE_BOOK).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let book_id = item.borrow();
            client.execute(&stmt, &[&book_id]).await?;
            Ok(())
        })
    };
    Ok(futures::stream::iter(book_id_list.into_iter().map(fut)))
}
pub(crate) async fn delete_book_exec_result(
    client: &impl sqlc_core::DBTX,
    book_id: i32,
) -> sqlc_core::Result<()> {
    client.execute(DELETE_BOOK_EXEC_RESULT, &[&book_id]).await?;
    Ok(())
}
pub(crate) async fn delete_book_named_func<'a, C, I>(
    client: &'a C,
    book_id_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<()>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<i32> + 'a,
{
    let stmt = client.prepare(DELETE_BOOK_NAMED_FUNC).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let book_id = item.borrow();
            client.execute(&stmt, &[&book_id]).await?;
            Ok(())
        })
    };
    Ok(futures::stream::iter(book_id_list.into_iter().map(fut)))
}
pub(crate) async fn delete_book_named_sign<'a, C, I>(
    client: &'a C,
    book_id_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<()>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<i32> + 'a,
{
    let stmt = client.prepare(DELETE_BOOK_NAMED_SIGN).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let book_id = item.borrow();
            client.execute(&stmt, &[&book_id]).await?;
            Ok(())
        })
    };
    Ok(futures::stream::iter(book_id_list.into_iter().map(fut)))
}
pub(crate) async fn get_author(
    client: &impl sqlc_core::DBTX,
    author_id: i32,
) -> sqlc_core::Result<Author> {
    let row = client.query_one(GET_AUTHOR, &[&author_id]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn get_biography<'a, C, I>(
    client: &'a C,
    author_id_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<serde_json::Value>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<i32> + 'a,
{
    let stmt = client.prepare(GET_BIOGRAPHY).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let author_id = item.borrow();
            let row = client.query_one(&stmt, &[&author_id]).await?;
            Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
        })
    };
    Ok(futures::stream::iter(author_id_list.into_iter().map(fut)))
}
pub(crate) async fn update_book<'a, C, I>(
    client: &'a C,
    arg_list: I,
) -> sqlc_core::Result<
    impl futures::Stream<
        Item = impl futures::Future<Output = sqlc_core::Result<()>> + 'a,
    > + 'a,
>
where
    C: sqlc_core::DBTX,
    I: IntoIterator + 'a,
    I::Item: std::borrow::Borrow<UpdateBookParams> + 'a,
{
    let stmt = client.prepare(UPDATE_BOOK).await?;
    let fut = move |item: <I as IntoIterator>::Item| {
        let stmt = stmt.clone();
        Box::pin(async move {
            use std::borrow::Borrow;
            let arg = item.borrow();
            client.execute(&stmt, &[&arg.title, &arg.tags, &arg.book_id]).await?;
            Ok(())
        })
    };
    Ok(futures::stream::iter(arg_list.into_iter().map(fut)))
}
