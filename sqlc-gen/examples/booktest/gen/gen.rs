/// @generated by the sqlc-gen-rust on sqlc-generate using sqlc.yaml
/// DO NOT EDIT.
pub(crate) const BOOKS_BY_TAGS: &str = r#"
select book_id, title, name, isbn, tags
from books
left join authors on books.author_id = authors.author_id
where tags && $1::varchar[]
"#;
pub(crate) const BOOKS_BY_TITLE_YEAR: &str = r#"
select book_id, author_id, isbn, book_type, title, year, available, tags
from books
where title = $1 and year = $2
"#;
pub(crate) const CREATE_AUTHOR: &str = r#"
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name
"#;
pub(crate) const CREATE_BOOK: &str = r#"
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags
"#;
pub(crate) const DELETE_BOOK: &str = r#"
delete from books
where book_id = $1
"#;
pub(crate) const GET_AUTHOR: &str = r#"
select author_id, name
from authors
where author_id = $1
"#;
pub(crate) const GET_BOOK: &str = r#"
select book_id, author_id, isbn, book_type, title, year, available, tags
from books
where book_id = $1
"#;
pub(crate) const SAY_HELLO: &str = r#"
select say_hello
from say_hello($1)
"#;
pub(crate) const UPDATE_BOOK: &str = r#"
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3
"#;
pub(crate) const UPDATE_BOOK_ISBN: &str = r#"
UPDATE books
SET title = $1, tags = $2, isbn = $4
WHERE book_id = $3
"#;
#[derive(postgres_derive::ToSql, postgres_derive::FromSql)]
#[derive()]
#[postgres(name = "book_type")]
pub enum BookType {
    #[postgres(name = "FICTION")]
    Fiction,
    #[postgres(name = "NONFICTION")]
    Nonfiction,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct Author {
    pub author_id: i32,
    pub name: String,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct Book {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: time::OffsetDateTime,
    pub tags: Vec<String>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct BooksByTagsRow {
    pub book_id: i32,
    pub title: String,
    pub name: Option<String>,
    pub isbn: String,
    pub tags: Vec<String>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct BooksByTitleYearParams {
    pub title: String,
    pub year: i32,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct CreateBookParams {
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: time::OffsetDateTime,
    pub tags: Vec<String>,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct UpdateBookIsbnParams {
    pub title: String,
    pub tags: Vec<String>,
    pub book_id: i32,
    pub isbn: String,
}
#[derive(sqlc_core::FromPostgresRow)]
#[derive()]
pub(crate) struct UpdateBookParams {
    pub title: String,
    pub tags: Vec<String>,
    pub book_id: i32,
}
pub(crate) async fn books_by_tags(
    client: &impl sqlc_core::DBTX,
    dollar_1: String,
) -> sqlc_core::Result<
    impl std::iter::Iterator<Item = sqlc_core::Result<BooksByTagsRow>>,
> {
    let rows = client.query(BOOKS_BY_TAGS, &[&dollar_1]).await?;
    let iter = rows
        .into_iter()
        .map(|row| Ok(sqlc_core::FromPostgresRow::from_row(&row)?));
    Ok(iter)
}
pub(crate) async fn books_by_title_year(
    client: &impl sqlc_core::DBTX,
    arg: BooksByTitleYearParams,
) -> sqlc_core::Result<impl std::iter::Iterator<Item = sqlc_core::Result<Book>>> {
    let rows = client.query(BOOKS_BY_TITLE_YEAR, &[&arg.title, &arg.year]).await?;
    let iter = rows
        .into_iter()
        .map(|row| Ok(sqlc_core::FromPostgresRow::from_row(&row)?));
    Ok(iter)
}
pub(crate) async fn create_author(
    client: &impl sqlc_core::DBTX,
    name: String,
) -> sqlc_core::Result<Author> {
    let row = client.query_one(CREATE_AUTHOR, &[&name]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn create_book(
    client: &impl sqlc_core::DBTX,
    arg: CreateBookParams,
) -> sqlc_core::Result<Book> {
    let row = client
        .query_one(
            CREATE_BOOK,
            &[
                &arg.author_id,
                &arg.isbn,
                &arg.book_type,
                &arg.title,
                &arg.year,
                &arg.available,
                &arg.tags,
            ],
        )
        .await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn delete_book(
    client: &impl sqlc_core::DBTX,
    book_id: i32,
) -> sqlc_core::Result<()> {
    client.execute(DELETE_BOOK, &[&book_id]).await?;
    Ok(())
}
pub(crate) async fn get_author(
    client: &impl sqlc_core::DBTX,
    author_id: i32,
) -> sqlc_core::Result<Author> {
    let row = client.query_one(GET_AUTHOR, &[&author_id]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn get_book(
    client: &impl sqlc_core::DBTX,
    book_id: i32,
) -> sqlc_core::Result<Book> {
    let row = client.query_one(GET_BOOK, &[&book_id]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn say_hello(
    client: &impl sqlc_core::DBTX,
    s: String,
) -> sqlc_core::Result<String> {
    let row = client.query_one(SAY_HELLO, &[&s]).await?;
    Ok(sqlc_core::FromPostgresRow::from_row(&row)?)
}
pub(crate) async fn update_book(
    client: &impl sqlc_core::DBTX,
    arg: UpdateBookParams,
) -> sqlc_core::Result<()> {
    client.execute(UPDATE_BOOK, &[&arg.title, &arg.tags, &arg.book_id]).await?;
    Ok(())
}
pub(crate) async fn update_book_isbn(
    client: &impl sqlc_core::DBTX,
    arg: UpdateBookIsbnParams,
) -> sqlc_core::Result<()> {
    client
        .execute(UPDATE_BOOK_ISBN, &[&arg.title, &arg.tags, &arg.book_id, &arg.isbn])
        .await?;
    Ok(())
}
